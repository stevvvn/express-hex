#!/usr/bin/env node
'use strict';
require('flow-remove-types/register')({ 'excludes': null });

const
	{ argv } = require('optimist'),
	appPath = (argv._[0] ? argv._[0] : process.cwd()).replace(/\/$/, ''),
	{ spawn } = require('child_process'),
	fs = require('fs'),
	path = require('path'),
	base = path.basename(path.resolve(`${__dirname}/..`)) === 'hex' ? `${__dirname}/..` : `${__dirname}/../hex`,
	templates = {},
	HEX_SRC = 'https://bitbucket.org/snyder13/hex.git',
	init = require('init-package-json')
	;

fs.readdirSync(`${base}/templates`).forEach((name) => {
	const idx = `${base}/templates/${name}/index.js`;
	if (fs.existsSync(idx)) {
		templates[name] = require(idx);
		templates[name].base = `${base}/templates/${name}`;
	}
});

if (!fs.existsSync(`${appPath}/package.json`)) {
	const initFile = path.resolve(process.env.HOME, '.npm-init');
	init(appPath, initFile, {}, (err, data) => {
		if (err) {
			console.log('aborted', err);
			process.exit();
		}
		installDeps();
	});
}
else {
	installDeps();
}

function installDeps() {
	spawn('npm', [ 'install', '--prefix', appPath, '--save', HEX_SRC ], { 'stdio': 'inherit' }).on('close', installTemplate);
}

function installTemplate() {
	if (argv.template && templates[argv.template]) {
		run(argv.template);
	}
	else {
		require('inquirer').prompt([
			{
				'name': 'template',
				'type': 'list',
				'choices': Object.keys(templates).map((value) => {
					return { value, 'name': `${value}: ${templates[value].descr}` };
				}),
				'default': 'default',
				'message': 'Which template?'
			}
		]).then((conf) => { run(conf.template); });
	}
}

/// @TODO allow templates to specify addtl deps
function run(template) {
	const
		pkg = JSON.parse(fs.readFileSync('./package.json')),
		files = templates[template].files,
		fileNames = Object.keys(files),
		tplBase = templates[template].base
		;
	let fileIdx = 0;
	const nextFile = () => {
		if (!fileNames[fileIdx]) {
			console.log('ok');
			return;
		}
		const file = fileNames[fileIdx];
		++fileIdx;

		console.log('\t', file, '-', files[file].descr ? files[file].descr : files[file]);
		if (fs.existsSync(`${appPath}/${file}`)) {
			console.log('\t\t[exists, skipping]');
			return nextFile();
		}
		if (/\/$/.test(file)) {
			fs.mkdirSync(`${appPath}/${file}`);
			return nextFile();
		}
		const writer = fs.createWriteStream(`${appPath}/${file}`);
		const writeNext = () => {
			writer.close();
			nextFile();
		};
		if (files[file].impl) {
			writer.write(files[file].impl(pkg, process.cwd()), writeNext);
			return;
		}
		if (fs.existsSync(`${tplBase}/${file}`)) {
			fs.createReadStream(`${tplBase}/${file}`).pipe(writer);
			writer.on('unpipe', writeNext);
			return;
		}
		throw new Error(`no source provided for ${file} (${tplBase}/${file})`);
	};
	nextFile();
}


// vi: ft=javascript
